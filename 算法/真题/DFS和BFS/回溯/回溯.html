<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 题目描述：给定两个整数 n 和 k，返回 1 ...n 中所有可能的 k 个数的组合。

    // 示例: 输入: n = 4, k = 2
    // 输出:
    // [
    //     [2, 4],
    //     [3, 4],
    //     [2, 3],
    //     [1, 2],
    //     [1, 3],
    //     [1, 4],
    // ]
    // 我们发现，只有双向箭头所指的结点组合被认为是有效结果，其它结点都被丢弃了。在寻找这三对结点组合的过程中，我们一旦找到一对，就停止继续往深处搜索，这就意味着一些结点压根没有机会被遍历到。

    // 这其实就是“剪枝”的过程——在深度优先搜索中，有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”。

    // 在这道题中，要做到剪枝，我们需要分别在组合问题的递归式和递归边界上动手脚：
    // 递归式：普通组合问题，每到一个新的坑位处，我们都需要对组合结果数组进行更新；这道题中，当且仅当组合内数字个数为 k 个时，才会对组合结果数组进行更新。
    // 递归边界：只要组合内数字个数达到了 k 个，就不再继续当前的路径往下遍历，而是直接返回。

    /*
        分析：
                1. 穷举所有可能
                2. 本身有限制条件---需要回溯
                3. 回溯---在递归中添加限制条件
                    1. 递归边界
                    2. 递归式
    */
    function fn(n, k) {
        var curr = [];
        var res = [];

        function dfs(nth) {
            //注意：这个边界不能加，加了以后会出错
            //因为它会把最外层（第一次进入函数）的循环先执行完，然后直接触发递归边界，然后就导致递归直接结束了。
            // if (nth = n) {
            //     if (curr.length === k) {
            //         res.push(curr.slice());
            //         return
            //     }
            //     return
            // }

            //关于递归边界：一方面由下面的if语句充当了一部分，另外一方面由下面的循环充当了一部分，当循环结束时就是整个递归结束时。

            //只要每次进行递归函数中，说明坑位就移动了一次（或者是坑位全部没有填充的情况）,那么就可以往结果中塞入一次数据---注意：我们是有限制条件的
            if (curr.length === k) {
                res.push(curr.slice());
                return
            }
            //在这里数字的使用和坑位的移动结合到一起了。因为每个数字用完之后，哪怕是没有放入到坑位中，之后也不会再使用了。就和坑位的移动结合到一块儿了。---这样的话就不需要进行数字的判断了。
            for (let i = nth; i < n; i++) {
                //两种情况
                curr.push(i + 1);
                console.log(1);
                //坑位填满，所以需要移动坑位
                dfs(i + 1);
                //第二种情况
                curr.pop();
            }
        }
        dfs(0);
        console.log(666);
        return res;
    }
    var arr = fn(4, 2);
    console.log(arr);
</script>

</html>