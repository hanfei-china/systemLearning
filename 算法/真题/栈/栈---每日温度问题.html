<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 题目描述: 根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

    // 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。

    // 提示：气温 列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在[30, 100] 范围内的整数。


    //思路：
    //解法一：暴力解决---第一遍遍历，找到每个温度，然后二次遍历，找到温度增加的地方
    //        问题：两层遍历，我们会进行很多无用的操作，比如75度的时候，我们第二遍遍历会走过71  69  72 。而这三个我们都没有做任何操作，但是实际上72是71的温度升高点。所以，暴力解决发在这里绝对不是适当的解决方法。
    //解法二：
    // 避免重复操作的秘诀就是及时地将不必要的数据出栈，避免它对我们后续的遍历产生干扰。
    // 拿这道题来说，我们的思路就是：尝试去维持一个递减栈。
    // 当遍历过的温度，维持的是一个单调递减的态势时，我们就对这些温度的索引下标执行入栈操作；只要出现了一个数字，它打破了这种单调递减的趋势，也就是说它比前一个温度值高，这时我们就对前后两个温度的索引下标求差，得出前一个温度距离第一次升温的目标差值。
    /**
     * @param {number[]} T
     * @return {number[]}
     */
    var temperatures = [73, 74, 75, 71, 69, 72, 76, 73];
    var arr = fn(temperatures);
    console.log(arr);

    function fn(arr) {
        //1. 创建一个用于存储结果的数组
        var res = new Array(arr.length).fill(0);
        //2. 创建一个栈
        var arr_1 = [];
        //3. 进行遍历循环
        for (let i = 0; i < arr.length; i++) {
            // 判断当前的栈是否维持一个递减的状态
            while (arr_1.length && arr[i] > arr[arr_1[arr_1.length - 1]]) {
                //如果不是递减状态，说明此时遍历到的数要大于栈中的最近入栈的值---要出栈，同时记录结果
                var res_1 = arr_1.pop();
                res[res_1] = i - res_1;
            }
            //当前还是递减状态，那么就将对应数的下标入栈
            arr_1.push(i);
        }
        return res;
    }
</script>

</html>