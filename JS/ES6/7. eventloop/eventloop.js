//例1
// for (var i = 0; i < 10; i++) {
//     setTimeout(function() {
//         console.log(i)
//     }, 1000)
// }
//结果：间隔一秒后，打印10个10


//例2
// setTimeout(function() {
//     console.log(1)
// }, 0)
// new Promise(function executor(resolve) {
//     console.log(2)
//     for (var j = 0; j < 100; j++) {
//         j = 99 && resolve()
//     }
//     console.log(3)
// }).then(function() {
//     console.log(4)
// })
// console.log(5)
//执行结果  2 3 5 4 1
/*
    分析：
        1. 执行同步代码，并发布宏任务和微任务
            1. 遇到一个定时器，放到宏任务列表（此时定时器已经开始计时，但是在同步任务完成之前，哪怕计时结束也不能执行）
            2. new Promise是同步代码.输出2，然后执行for循环，循环结束后，执行resolve，遇到then微任务。将其放入到微任务列表中。然后输出3
            此时，同步代码执行完毕，输出2 3 5.微任务列表中有一个then方法。宏任务列表中有一个定时器。

            4. 执行微任务列表。输出4
            5. 微任务列表清空，执行一个宏任务---输出1
            5. 微任务列表清空。返回找宏任务，发现宏任务列表同样清空。event loop销毁。
*/


/*
    event loop执行机制
            1. 执行同步任务，将遇到的微任务放到微任务列表中，把宏任务放到宏任务列表中
            2. 执行微任务列表
            3. 将可执行的宏任务拿出来一个执行，遇到微任务继续放入微任务列表中。宏任务放到宏任务列表中
            4. 执行完一个宏任务，就要将依赖其的所有微任务执行。
            5. 当执行完微任务后，再去宏任务列表中拿出来一个可以执行的宏任务执行。以此往复。
*/

/*
    发现：
        1. 在执行完同步代码时，我们首先要执行的是微任务。而且每次执行完一个宏任务后，会再次清空微任务列表。
        2. 为什么要那样？
            1. 宏任务是不确定时间间隔的
            2. 微任务都是依赖同步代码或者依赖宏任务的
            3. 所以当同步代码执行完毕后，或者一个宏任务执行完毕后，都要将其附带的微任务执行完毕。
*/

/*
    宏任务：
        1. setTimeout
        2. setInterval
        3. I/O   比如ajax
    微任务：
        1. then
        2. process.nextTick(node api)
*/

/*
    我们在使用promise简化异步任务的本质：
        1. 在new Promise的过程中（执行同步代码的时候），会发布异步代码（一般是宏任务，比如Ajax或者定时器等）。
        2. 然后把需要异步执行的代码放入到then中。那这个微任务此时并不会发布，而是在前面的宏任务执行完毕后才会发布这个微任务。
        3. 然后在这个宏任务执行完毕后，就要去清空微任务列表。正好会继续执行then方法。
*/