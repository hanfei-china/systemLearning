//闭包：那些能够访问自由变量的函数
//自由变量：既不是函数的参数，也不是函数的局部变量的变量

//所以：闭包=函数 + 自由变量

//理论闭包：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。

/**
    实践闭包：
            1. 创建它的上下文已经销毁，而它依旧存在（我们使用的时候基本都是指   从父函数中返回一个子函数  。  那么此时父函数执行完毕以后就销毁了，而子函数作为返回值没有执行，也没有销毁）
            2. 在代码中引用了自由变量。且这个自由变量需是其父函数内部的一个变量或者参数。
 */


//总结：我们在使用过程中，要想创建闭包。首先，要通过父函数返回一个子函数；然后，在子函数中书用父函数的一个参数或者局部变量。这样在父函数执行完毕并销毁后，其内部的局部变量或者参数会形成一个闭包用于保存这个值。
//另外，我们在ES6中在某些地方可以使用let来代替闭包。let会形成一个块作用域。


//例1

// var arr = [];
// for (var i = 0; i < 3; i++) {
//     arr[i] = function() {
//         console.log(i);
//     }
// }
// arr[0]();
// arr[1]();
// arr[2]();


//例2     使用闭包
// var arr = [];
// for (var i = 0; i < 3; i++) {
//     arr[i] = (function(i) {
//         return function() {
//             console.log(i);
//         }
//     })(i);
// }
// arr[0]();
// arr[1]();
// arr[2]();
//注意：闭包函数的父函数必须要传入参数，否则的话又和上面的一样了。


//例3     使用let
var arr = [];
for (let i = 0; i < 3; i++) {
    arr[i] = function() {
        console.log(i);
    }
}
arr[0]();
arr[1]();
arr[2]();