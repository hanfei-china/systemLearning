1. set
   1. 一般用于数组去重
   2. 是一种***集合***的数据结构
   
2. 集合
   1. 是由无序且唯一（不能重复）的项组成的
   2. 类似与一个没有重复的、无序的数组

3. map
   1. 用于数据存储
   2. 是一种***字典***的数据结构

4. [object Object]数据

5. forin遍历对象时，break和continue都可以正常使用。但是不能使用return。

6. forEach使用return不会打断循环，只是打断当前循环代码，跳入下一个循环。要想打断，可以使用some。

7. 奇怪的问题

   ```html
   <el-table-column class-name="item-un-sort" width="200px">
             <!-- 自定义表头 -->
             <template slot="header" slot-scope="{scope}">
               <el-popover placement="bottom" width="120" trigger="hover">
                 <div style="display:flex;flexDirection:column;alignItems:center;">
                   <p
                     @click="changeSortStyle(1)"
                     :class="{'normalSortStyle':true,'selectSortStyle':formInfo.sort===1}"
                   >按提问次数升序</p>
                   <p
                     @click="changeSortStyle(2)"
                     :class="{'normalSortStyle':true,'selectSortStyle':formInfo.sort===2}"
                   >按提问次数降序</p>
                 </div>
                 <!-- <el-button slot="reference">click 激活</el-button> -->
                 <div slot="reference">
                   <span>按提问次数</span>
                   <span style="marginRight:5px;">{{formInfo.sort===1?'升序':'降序'}}</span>
                   <span
                     style="color:#409eff;fontSize:14px;"
                     :class="{'el-icon-caret-bottom':formInfo.sort===2,'el-icon-caret-top':formInfo.sort===1}"
                   ></span>
                 </div>
               </el-popover>
             </template>
             <!-- 自定义表格内容 -->
             <template slot-scope="{row}">{{row.projectNumber}}</template>
           </el-table-column>
   ```

   **使用了一个组件，然后内部有作用域插槽。在设置自定义表头时，如果没有slot-scope="{scope}"这一句，响应式不能响应，但是这个值其实并没有使用。所以根本问题在哪里呢？？？？？？？？**   

   **猜测：插槽中，匿名插槽和具名插槽都是在初始化的时候传给子组件的，也就是说，哪怕使用了data数据，但是只有初始化的时候才能有效。在后续就没有响应了。而作用域插槽则可以使用子组件提前传入的值，同时也可以使用父组件的data数据（有响应式）。那么三者的差别就是slot-scope属性的有无。所以vue内部判断是否为作用域插槽就是根据这个属性的有无判断的。**  

   总结：

   1. 匿名插槽和具名插槽使用父组件的data数据时，只有初始化有效，后续没有相应能力
   2. 作用域插槽既可以使用父组件传给子组件的值，又可以直接使用父组件的data数据。且在使用父组件的data数据时有响应式
   3. vue内部判断是否为作用域插槽是根据slot-scope属性的有无来判断的。（新版的vue好像这个属性名变化了）
   4. -------------------------------------隔了一段时间再次遇到
   5. slot-scope的作用其实意味着可以访问子组件内部的数据了

8. 作用域插槽的意义：**组件和业务分离！！！** 

   1. 一个好的组件的根本要求：耦合性极低
      1. 数据解耦
      2. 方法解耦
      3. 样式解耦
   2. 那么如何通过作用域插槽实现呢？
      1. 当没有传入作用域插槽对应的内容时，默认样式如何实现  
   3. 可以参考element组件库的组件。尤其时表格组件！！！

9. 有时候父子组件传值时，子组件通过props接受父组件的传值。但是在created钩子函数或者methods方法中却无法使用这个值（输出时发现是空的）。

   1. 原因：可能父组件的这个值是请求回来的，此时子组件执行太快，所以没有传过来。还有一种情况是父组件的值不是请求的，这种情况推测也是由于子组件执行太快导致的
   2. 解决方法：在子组件中通过watch进行监听，然后在监听器中执行相关代码。

10. vue项目中子组件要想从父组件中获取数据的方法

   1. 父子通信---props接收---只要父组件的值发生变化就会给子组件传递，通信次数较高

   2. vuex---不是动态的

   3. 在子组件中调用父组件的方法，然后父组件的方法是一个高阶函数。那么子组件调用的时候传入一个函数，这个函数就会为子组件中的一个变量进行赋值，然后供子组件使用。

      ```javascript
      this.$emit("getSameIds", (val) => { archiveIds = val; });
      //之后就可以在子组件中使用archiveIds这个变量了
      ```

11. JS语言中有一个global的全局对象，但是这个对象是和JS运行的环境有关的。当JS文件在浏览器中运行，那么就有一个全局对象是window。在nodejs中运行就有一个global的全局对象。

    1. 所以，直接在JS文件中使用window对象是会出错的。

12. ```javascript
    var data = {
        obj: {},
        a: 2
    };
    
    function setWatch(obj, key) {
        let val = obj[key];
        Object.defineProperty(obj, key, {
            get() {
                return val
            },
            set(newVal) {
                console.log(newVal);
                val = newVal;
            }
        })
    }
    setWatch(data, 'obj');
    setWatch(data, 'a');
    // data.obj.a = 3; //没有输出
    data.obj = null; //null
    data.a = 3; //3
    
    
    //结论：
    /**
        1. Object.defineProperty方法不能检测到对象属性的添加与否;
        2. Object.defineProperty能检测到这个值的类型变化或者值的有无（复杂数据也是）
        3. vue中watch监听器，我们经常用来监听props数据，其实就是监听这个数据的有无，而不是监听数据本身的变化
        4. vue中watch监听器的deep属性，其实就是将对象进行了遍历，然后分别进行监听器的注册。所以使用deep属性，性能消耗很大。
     */
    ```

13. vue指令

    1. ```javascript
       directives: {
           loadmore: {
             inserted: function(el, binding) {
               // 获取element-ui定义好的scroll盒子
               const SELECTWRAP_DOM = el.querySelector(
                 ".el-select-dropdown .el-select-dropdown__wrap"
               );
       
               SELECTWRAP_DOM.addEventListener("scroll", function() {
                 /*
                  * scrollHeight 获取元素内容高度(只读)
                  * scrollTop 获取或者设置元素的偏移值,常用于, 计算滚动条的位置, 当一个元素的容器没有产生垂直方向的滚动条, 那它的scrollTop的值默认为0.
                  * clientHeight 读取元素的可见高度(只读)
                  * 如果元素滚动到底, 下面等式返回true, 没有则返回false:
                  * ele.scrollHeight - ele.scrollTop === ele.clientHeight;
                  */
                 const CONDITION =
                   this.scrollHeight - this.scrollTop <= this.clientHeight;
       
                 if (CONDITION) {
                   //触底时触发指令传入的函数
                   binding.value();
                 }
               });
             }
           }
         },
       ```

       

### 14.下载文件

1. 方法一：

   1. ```javascript
      //定义一个方法---用来打开文件
      function exportExcel(resp) {
          let fileName = resp.headers.filename;
          let link = document.createElement('a');
          let blob = new Blob([resp.data], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
          link.style.display = 'none';
          let blobURL = window.URL.createObjectURL(blob);
          link.href = blobURL;
          link.setAttribute('download', decodeURIComponent(fileName));
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(blobURL);
      }
      //下面这个方法用来发起请求，获取文件资源
      downLoad(){
            let params = {};
            this.$request
              .post("/api/admin/branch/exportBranchExcelDate", params, {
                responseType: "blob"
              })
              .then(resp => {
                exportExcel(resp);
              });
          }
      ```

2. 方法二

   1. ```javascript
       var url =
               requestBaseUrl +
               "/api/admin/branch/exportBranchExcelDate?branchClass=" +
               params.branchClass +
               "&searchContent=" +
               params.searchContent +
                "&needMemberCount=true&startTime=" +
               params.startTime +
              "&endTime=" +
              params.endTime;
             window.open(url);
      ```

      

### 15. vue中添加遮罩层的方法

```javascript
//element组件库给vue全局注册了一个对象$loading，通过这个对象我们可以创建一个全局的方法，用于控制是否打开遮罩层。然后把这个方法在axios的拦截器中使用，这样的话就可以在发起请求的时候打开遮罩层，在请求结束后关闭遮罩层。
export default function openLoading() {
    const loading = this.$loading({ // 声明一个loading对象
            lock: true, // 是否锁屏
            // text: '拼命加载中', // 加载动画的文字
            spinner: 'el-icon-loading', // 引入的loading图标
            background: 'rgba(0, 0, 0, 0.7)' // 背景颜色
        })
        // setTimeout(function() { // 设定定时器，超时2S后自动关闭遮罩层，避免请求失败时，遮罩层一直存在的问题
        //     loading.close() // 关闭遮罩层
        // }, 2000)
    return loading
}
```

### 16 void

1. 作用---无论void后面的表达式是什么，都会保证返回undefined。同时，可以填充到url中，因为url可以运行Javascript：协议。所以为了点击这个标签的时候不进行页面跳转或者刷新（url啥都不写的时候刷新）。我们都会在后面用它。
   1. void (任何东西)    结果都是undefined
   2. void 0    结果同样是undefined
   3. \<img src="javascript: void 0"/>
   4. \<a href="javascript:void 0"/>
2. 为什么要用void？
   1. 因为undefined在JS中并不是保留字，不管是在window环境还是node环境，在上下文中（全局或者局部）都可以直接定义一个名为undefined的变量的，然后给这个变量赋值。所以我们从上下文环境中去取一个undefined就并非为100%可靠了。