# 1. 项目---智能客服

## 整体流程

1. 业务分析
   1. 从业务的角度上，按照使用的流程进行步骤的划分（**注意：这里的业务也要分开，分别从客户端和客服端进行分析，不能混为一谈。否则的话流程混杂！！！**）
      1. 客服上线
         1. 与服务器建立webSocket连接
         2. 客服状态进行变化，由下线转为上线
         3. 服务器给客服传送    ***我的***    中展示的客户端的信息列表
      2. 其中某个回话由机器人或者其他同事转接到本人
         1. 该回话的所属人发生变化，然后由服务器通过webSocket进行广播
         2. 各个客服接收到广播后，由回话的新的所属人信息去更新回话列表内容
      3. 进行对话
         1. 没次对话，就是对当前会话进行消息的插入
2. 功能模块分析
   1. 通过业务逻辑，将其各个功能模块提取，然后将同类功能进行整合
   2. 功能分析

## 总结

### 1. 分离的重要性

1. 不管是前后端分离，还是前端的模板与数据分离，或是后端的功能分离。分离的目的都是将整体拆分，使得各个模块之间可以项目沟通，但是又可以针对性的进行处理。便于开发、维护。

### 2. 前端分离

1. 数据与模板相分离（**这是前端最主要的分离！！！**）
2. 组件分离---即子组件的使用
   1. 同样是将一个功能复杂的父组件，按照功能划分，分成一个个单独的子组件
   2. 也有可能是直接模块的划分，比如一个页面中，直接划分为4块，然后分别为单独的子组件。**但是这种划分也要注意功能的分离，避免出现两个组件中有功能的交叉**。
3. 在前端开发中，通常先考虑功能的分离（组件分离），然后在此基础上进行数据和模板的分离。
4. 所以，一个好的前端，一定不仅仅懂技术，一定是懂业务的。懂业务不是说知道这个业务需求怎么做，而是明白在每个业务的需求下，该如何去进行搭建（个人认为是功能、模块等的一个划分），以便实现更优的开发和维护！

## 项目使用到的小技术

### 1. 防抖和节流

1. 防抖---设定一个时间间隔，只有下一次事件触发的间隔大于这个时间间隔，才会去执行本次事件。否则就会忽略本次事件，以下一个事件为基础，重新计算时间间隔。

   1. 特点：执行时机不确定，只有当两次间隔超过设定值才会执行，否则会一直向后推延。
   2. 在业务中，防抖经常用于执行**最后一次**的情况
   3. 如    搜索框

2. 节流---设定一个时间段，然后在这个时间段内只执行一次

   1. 特点：在时间段内，必然会执行一次
   2. 在业务中，节流经常用于大量连续事件中的简化
   3. 如   图片跟随鼠标移动

   ```javascript
   //防抖
       var timer=null;
       function fangdou() {
           clearTimeout(timer);
           timer=setTimeout(() => {
               console.log(111);
           }, 1000);
       }
   
       //节流
       var aaa=true;
       function jieliu() {
           if (!aaa) {
               return
           }
           aaa=false;
           setTimeout(() => {
               aaa=true;
               console.log(222);
           }, 1000);
       }
   ```

### 2. 小程序中内嵌H5页面

```javascript
小程序内嵌客服思路：
1. 问题：
  1. 后端需要前端在发起请求的时候，必须携带cookie信息
  2. 小程序内嵌H5页面，只能通过web-view组件来实现，且H5页面中没有办法直接在浏览器中储存cookie
2. 思路
  1. 要求小程序中想要使用只能客服，必须要登录小程序
  2. 在进入到智能客服时，通过web-view组件的url属性传递用户的userInfo信息（从微信的本地存储中获取），然后H5页面通过路由来获取信息
  3. H5页面获取到用户信息后，设置：document.cookie='cookieInfo='+escape('cookievalue')；这样应该就可以实现H5页面在小程序中保存cookie信息了。
  4. escape()方法的作用是将传入的值转换为URL编码的形式---因为cookie的值要求是URL编码的格式
```

## 2. 杂谈

### 1. 数组的sort方法

```javascript
var arr=[2,1,4,3,6,5,8,7];
    arr.sort((a,b)=>{
        return a-b;   //升序
    });
    console.log(arr); //[1,2,3,4,5,6,7,8]
    arr.sort((a,b)=>{
        return a-b;   //降序
    });
    console.log(arr); //[8,7,6,5,4,3,2,1]
```

### 2.请求

1.  vue中的axios的delete请求和post请求、put请求的差别

   1.  post和put有三个参数，url,data和config，所以在使用这两个时，可以写成axios.post(api,{id:1}),axios.put(api,{id:1}),但是delete只有两个参数：url和config，data在config中，所以需要写成 **axios.delete(api,{params:{id:1}})**  

   2. 当后端接受的格式为url字符串拼接方式时

      ```javascript
      var param={id:1,name:'zhangsan'}
      this.$axios.delete("/ehrReferralObjPro", {params: param}).then(function(response) {
        }
      ```

   3. 当后端接受的数据格式为JSON格式时

      ```javascript
      var param={id:1,name:'zhangsan'}
      this.$axios.delete("/ehrReferralObjPro", {data: param}).then(function(response) {
        }
      ```

### 3. 引用类型数据的复制

1. JSON方法

2. Object.create方法

   1. 复制出来的对象不能通过字面量的方式修改

   2. 本质上是原型式的一种继承方法

   3. ```javascript
          var obj = {
              name: '唐僧',
              title: '师傅'
          };
          var obj1 = Object.create(obj);
          console.log(obj1); //是个空对象，但是__proto__指向了原型（obj），所以可以识别到name和title属性
      
      
          //单独去改变obj1的属性，相当于给obj1添加了name属性，所以也不会顺着原型去改变原型上的name属性
          obj1.name = '孙悟空';
          console.log(obj1.name); //孙悟空
          console.log(obj.name); //唐僧
      
      
          //采用字面量的方式为obj1进行赋值，就会将其改变。原型指向了Object的原型上
          obj1 = {
              name: '猪八戒',
              title: '好吃懒做'
          }
          console.log(obj1); //{name: "猪八戒", title: "好吃懒做"}
          console.log(obj); //{name: "唐僧", title: "师傅"}
          console.log(obj1.__proto__ == Object.prototype); //true
      
      
          //Object.create方法可以用来复制引用类型。但是注意的是复制出来的数据不能通过字面量的方式去修改。
      ```

3. 递归

### 4. 面试题目

 1. tcp三次握手的原理和过程，tcp与udp有什么区别
2.http和https有什么区别，加密方式是什么，传输原理是什么
3.防抖和节流有什么用，一般的使用场景，原理是什么
4.手写判断一个字符串是不是回文字符串，如果能使用js中的方法，你会使用哪一个方法
5.跨域是什么？怎么解决跨域？
6.状态码都有哪些？304是指什么意思
7.浏览器的缓存机制是什么，怎么实现缓存，怎么想让特定文件进行缓存
8.函数和对象的区别是什么
9.redux是什么，为什么要使用redux，工作原理是什么
10.js中的事件循环是什么原理 





# 2. 算法---数据结构

## 1. 数组

### 1. 一维数组

1. 数组的创建、访问及遍历
   1. 创建一个长度固定的空数组
   2. 创建一个长度固定，且内部的值都相同的数组
   3. 访问
   4. 遍历---目的：获取到数组的每一项，同时知道其对应的位置（下标）
      1. forEach和for相比，功能一样，使用起来稍微简单一点
      2. map和forEach相比，使用方法完全一直。但是map是在原数组的基础上，对每一项进行了处理，这个处理方法高度一致。然后将处理后的每一项组成了一个新的数组
      3. 性能比较：for循环的性能最高。所以，在没有特殊需求的情况下，最好使用for循环去遍历数组

### 2. 二维数组

1. 二维数组的创建（初始化）--初始化二维数组---创建一个有固定长度且都有一个空数组为值的数组

   ```javascript
       //此时不能使用fill去填充了，因为此时填充的是数组---即引用类型。这种情况下修改第一个数组的值，后面的全都改了
       var arr_2=new Array(7).fill([]);
       //arr_2=[[],[],[],[],[],[],[]];
       arr_2[0][0]=1;
       //arr_2=[[1],[1],[1],[1],[1],[1],[1]];
   
       //所以，二维数组的初始化要通过遍历来实现
       //方法一：
       var arr_3=new Array(7);
       for (let i = 0; i < arr_3.length; i++) {
           arr_3[i]=[];
       }
       //方法二：
       var arr_4=new Array(7).fill(0).map(item=>new Array());
   ```

## 2. 栈和队列

### **总体思想：**

1. **栈和队列作为运算受限的线性表，用链表也可以运算。但是对于前端来说没必要，直接按照特殊的数组进行处理即可。**
2. **栈和队列的区别就是：二者对于数组的增删操作有不同的限制**

### 1. 栈

1. 只用pop和push实现数组的增删---栈一般只允许从尾部添加或取出元素
2. **先进后出**原则

### 2. 队列

1. **先进先出**原则
2. 使用push和shift进行数组的增删操作---只允许从尾部添加元素，从头部取出元素

## 3. 链表

### 1.特点：

1.  与数组的异同点：
   1. 都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是**离散**的。 
   2.  数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段**连续**的内存空间。元素与元素之间，紧紧相连 。所以可以根据数组的下标来获取数组的元素。

### 2.表示方法

1. JS中链表的表现方法---嵌套的对象形式

   ```javascript
   {
   	//数据域
   	value:1，
   	//指针域
   	next:{
   		value:2,
   		next:....
   	}
   }
   ```

2. 链表中数据是由一个个的**结点**组成的。每个结点都包含两部分内容：数据域和指针域。

   1. 数据域包含的内容是本结点的数据值
   2. 指针域包含的内容是**下一个**结点的信息

3. 通过每个结点的指针域我们就可以依次获取到链表中的每一个结点的值了---即便链表数据在内存中无序摆放，我们也可以获取到值。

4. **注意点**： 要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置 

### 3. 链表**结点**的创建

```javascript
//构造函数---用于创建链表元素
    function Fn(data) {
        this.value=data;
        this.next=null;
    }
    const aaa=new Fn(222);
    aaa.next=new Fn(333);
```

### 4. 链表结点的添加

```javascript
//Fn()构造函数是上面的构造函数
//本来的两个结点
var node1=new Fn(1);
node1.next=new Fn(2);
//要插入第三个结点
var node3=new Fn(3);
node3.next=node1.next;
node1.next=node3;
```

### 5. 链表结点的删除

```javascript
//最初的结点
var node1=new Fn(1);
var node2=new Fn(2);
var node3=new Fn(3);
node1.next=node2;
node2.next=node3;
//删除结点2
node1.next=nede3;
node2.next=null;

```

### 6. 链表和数组的辨析

1. 数组是有连续内存的
   1.  **我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)** 
2. JS的数组
   1. 当JS数组内部存储的数据类型一致时，这个数组的内存时连续的。如[1,2,5,6,8]
   2. 当JS数组中的数据类型不一致时。则数组的内存是不一致的。

### 7. 链表与数组的性能比较

1. 链表高效的增删操作

   1. 在链表中，添加和删除操作的复杂度是固定的。不管链表中的结点个数n有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。因此我们说链表增删操作的复杂度是常数级别的复杂度，用大O表示法表示为O（1）；

2. 链表麻烦的访问操作

   1.  当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做： 

      ```javascript
      // 记录目标结点的位置
      const index = 10  
      // 设一个游标指向链表第一个结点，从第一个结点开始遍历
      let node = head  
      // 反复遍历到第10个结点为止
      for(let i=0;i<index&&node;i++) {
          node = node.next
      }
      ```

   2.  随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。 

   3.  但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))： 

## 4.树与二叉树

### 1. 树

- 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
- 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
- “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
- “叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。

### 2. 二叉树

1. 它可以没有根结点，作为一棵空树存在

2. 如果它不是空树，那么**必须由根结点、左子树和右子树组成，且左右子树都是二叉树**

3.  注意，**二叉树不能被简单定义为每个结点的度都是2的树**。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。

4. 二叉树的编码实现

   ```javascript
   function TreeNode(val){
       thia.val=val;
       this.left=null;
       this.right=null;
       //为何将其左右树结点都设置为null？因为左右相当于一个指针，如果有左右树结点才有值，没有的话就是空。
       //但是，每个二叉树结点有可以有左右树结点，所有要提前声明，是否有值那就依情况而定了。
   }
   let treeNode1=new TreeNode(1);
   let treeNode2=new TreeNode(2);
   let treeNode3=new TreeNode(3);
   treeNode1.right=treeNode2;
   treeNode1.left=treeNode3;
   ```

### 3. 递归

1. 递归使用的条件---将某个子节点作为一个根节点传入
2. 递归的边界条件---什么时候结束递归
3. 递归的二要素：
   1. 递归式
   2. 递归边界



## 5. 各种数据结构的特点和使用

1. 链表---对于数据的增、删操作特别方便
2. 数组---对于数组的改、查特别方便---因为需要对数组的元素进行访问
3. 以上，数组和链表两种数据结构适用于对数据本身进行增删改查操作。而栈、队列以及二叉树，更多的是适用于在业务中对数据处理时的逻辑要求。
   1. 队列---先进先出
   2. 栈---先进后出
   3. 二叉树---有自己独有的数据结构要求

## 6. 二叉树的遍历

```javascript
    //二叉树
    var obj={
        val:1,
        left:{
            val:2,
            right:{
                val:5,
                right:null,
                left:null
            },
            left:{
                val:4,
                right:null,
                lfet:null
            }
        },
        right:{
            val:3,
            left:null,
            right:{
                val:6,
                right:null,
                left:null
            }
        }
    }
    //二叉树的遍历
    //要求：输出每个结点的值

    //先序遍历    根节点--左子树--右子树
    function fn(obj) {
        if (!obj) {
            //此时，这个结点为空
            return 
        }
        console.log('此时遍历的结点是： '+obj.val);
        fn(obj.left);
        fn(obj.right);
    }

    //中序遍历    左子树--根节点--右子树
    function fn_1(root) {
        if (!root) {
            return
        }
        //先遍历左子树
        fn_1(root.left);
        console.log('此时遍历的结点是： '+root.val);
        fn_1(root.right);
    }

    //后序遍历    左子树--右子树--根节点
    function fn_2(obj) {
        if (!obj) {
            return 
        }
        fn_2(obj.left);
        fn_2(obj.right);
        console.log('此时遍历的结点是： '+obj.val)
    }
```

## 7. 算法优略评价---时间复杂度和空间复杂度

1. 时间复杂度：代码执行次数

2. 空间复杂度：变量创建数量

   ```javascript
   	function fn(arr) {
           var n=arr.length;
           for (let i = 0; i < n; i++) {
               console.log(arr[i]);
           }
       }
       //时间复杂度为O(n),空间复杂度为O(1);
       function fn_1(n) {
           var arr=[];
           for (let i = 0; i < n; i++) {
               arr[i]=i;
           }
       }
       //时间复杂度为O(n),空间复杂度为O(n);
       function fn_2(n,m) {
           for (let i = 0; i < n; i++) {
               for (let j = 0; j < m; j++) {
                   console.log(i,j);
               }
           }
       }
       //时间复杂度为O(n^2),空间复杂度为O(1);
   ```

   

# 3. 算法真题

## 1. 数组

### 1. map的妙用

#### 1. Map的介绍和使用

1. Map的介绍

   1. 特点：提供了“值-值”的数据结构。键名可以为任何数据类型。是一个更完善的hash结构。
   2. 和对象的比较：区别于对象，对象的属性只能为字符串，如果传入一个对象，那么键名就会变成[Object Object]。

2. Map的使用

   ```javascript
   //1. 初始化
       let map1=new Map();
       //2. 赋值---通过键值对的形式，键可以是对象、数组、undefined等任意类型数据
       map1.set({age:18,name:'张三'},1);
   
       var arr=[
           {age:19,name:'李四'}
       ]
       map1.set(arr,2);
   
       var arr_1=[
           ['age','20'],
           ['name','王五']
       ];
       map1.set(arr_1,3);
       map1.set(undefined,4);
       console.log(map1); //Map(4) {{…} => 1, Array(1) => 2, Array(2) => 3, undefined => 4}
       //3. 获取值
       console.log(map1.get(arr_1));   //结果为3
   //4. 获取键值对的个数---长度
       console.log(map1.size);   //结果为4
       //5. has方法---判断是否有指定的键；输入键名，返回Boolean值
       console.log(map1.has(arr));  //true
       console.log(map1.has('arr'));  //false
       //6. delete方法---删除指定的键；输入键名
       map1.delete(arr_1);
       //7. clear方法---清空所有的键
       map1.clear();
   ```

3. Map的遍历

   ```javascript
   let mp=new Map();
       mp.set('age',16);
       mp.set('sex','女');
       mp.set('name','貂蝉');
       //一：使用forof遍历
           //1. 遍历键---keys方法
       for (const key of mp.keys()) {
           console.log(key);  //age  sex  name
       }
           //2. 遍历值---values方法
       for (const value of mp.values()) {
           console.log(value);  //16  女  貂蝉
       }
           //3. 遍历键值---entries方法
       for (const entry of mp.entries()) {
           console.log(entry);    //['age',16]  ['sex','女']  ['name','貂蝉']
       }
   ```

#### 2. 真题

```javascript
    //真题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    //           你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
    // 示例: 给定 nums = [2, 7, 11, 15], target = 9
    //          因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]

    //解法一：暴力解法
    function fn(arr, num) {
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] + arr[j] === num) {
                    return [i, j];
                }
            }
        }
    }
    var arr = [2, 7, 11, 15];
    var target = 9;
    var bbb = [];
    bbb = fn(arr, target);
    console.log(bbb);


    //解法二：使用map
    //原因：在暴力解法中，时间复杂度为O(n^2);空间复杂度为O(1);那么我们是否可以用空间来换取时间呢？也就是将时间复杂度降低为O(n);空间复杂度为O(n)；
    //反思：以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。

    //使用对象来模拟map的效果
    function fn_1(arr,num) {
        var obj={};
        for (let i = 0; i < arr.length; i++) {
            //将第一次循环的值全部保存下来
            //为什么要将数组的值作为对象的属性？因为我们直接去找的对象的属性
            if (obj[num-arr[i]]!==undefined) {
                return [obj[num-arr[i]],i];
            }
            obj[arr[i]]=i;
        }
    }
    var ccc=fn_1(arr,26);
    console.log(ccc);


    //使用map来是实现
    function fn_2(arr,num) {
        var mp=new Map();
        for (let i = 0; i < arr.length; i++) {
            if (mp.has(num-arr[i])) {
                return [mp.get(num-arr[i]),i]
            }
            mp.set(arr[i],i);            
        }
    }
    var ddd=fn_2(arr,9);
    console.log(ddd);
```

#### 3. 重点：

1. **任何加法都可以转换为减法**
2. **遇到两层循环时，要考虑是否能够通过空间来换取时间，进而优化代码**

### 2. 双指针法

#### 1. 真题

```javascript
    //真题描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
    // 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
    //示例: 输入:
    // nums1 = [1,2,3,0,0,0], m = 3
    // nums2 = [2,5,6], n = 3
    // 输出: [1,2,2,3,5,6]

    //解法---双指针法---有序数组
    var nums1 = [1, 2, 3, 0, 0, 0], m = 3;
    var nums2 = [2, 5, 6], n = 3;
    function fn(nums1, m, nums2, n) {
        //创建指针，指向两个数组的最后一位有效位
        var i = m - 1;
        var j = n - 1;
        var k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums2[j] > nums1[i]) {
                nums1[k] = nums2[j];
                j--;
                k--;
            } else {
                nums1[k] = nums1[i];
                i--;
                k--;
            }
        }
        while (j >= 0) {
            nums1[j] = nums2[j];
            j--;
            // k--;
        }
        return nums1;
    }
    var arr = fn(nums1, 3, nums2, 3);
    console.log(arr);
```

#### 2. 重点分析

1. 这是两个**有序**的**数组**，所以可以通过指针的移动来实现所有成员的访问和查找
   1. 重点词：有序    数组
   2. 场景：比大小、求和

### 3. 对撞指针

#### 1. 真题



### 4. 数组方法总结

1. Map

   1. 使用场景：两层循环，时间复杂度太高，通过空间换时间

2. 双指针法

   1. 使用场景：有序数组

3. 对撞指针

   1. **这里我给大家两个关键字——“有序”和“数组”。**
      **没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！**

      **即便数组题目中并没有直接给出“有序”这个关键条件，我们在发觉普通思路走不下去的时候，也应该及时地尝试手动对其进行排序试试看有没有新的切入点——没有条件，创造条件也要上。**

      **对撞指针可以帮助我们缩小问题的范围，这一点在“三数求和”问题中体现得淋漓尽致：因为数组有序，所以我们可以用两个指针“画地为牢”圈出一个范围，这个范围以外的值不是太大就是太小、直接被排除在我们的判断逻辑之外，这样我们就可以把时间花在真正有意义的计算和对比上。如此一来，不仅节省了计算的时间，更降低了问题本身的复杂度，我们做题的速度也会大大加快。**   
   
4. map------记录已经遍历过的数据，减少需要进行重复遍历的操作

5. 指针---主要是双指针------主要是通过双指针来处理有序数组，同时还能缩短遍历的次数------降低问题的复杂度，同时节省计算时间。

## 2. 字符串

### 1. 字符串的反转

```javascript
	var str='123456';
    var new_str=str.split('').reverse().join('');
    console.log(new_str);//'654321'
```

### 2. 判断是否为回文字符串

```javascript
    var str = 'yessey';
    var str='yesabsey'
    //方法一：利用回文字符串的定义---正反相同
    //这个方法看起来好像简单，其实用到了好几个数组的方法。
    function fn_1(str) {
        var str_1 = str.split('').reverse().join('');
        if (str_1 === str) {
            return true;
        } else {
            return false;
        }
    }
    //方法二：利用回文字符串的特性---对称性
    function fn_2(str) {
        var l = str.length;
        var arr=str.split('');
        var btn = true;
        for (let i = 0; i < l / 2; i++) {
            if (arr[i]!==arr[l-1-i]) {
                btn=false;
            }
        }
        return btn;
    }
    console.log(fn_1(str));
    console.log(fn_2(str));
```





# 3. 真题

## 1. 数组

### 1. 体型

1. 两数求和
   1. 求和转换为求差
   2. 使用map或者对象模拟map
      1. 通过空间换时间---通过增大内存的方法，简化了一层循环
2. 将两个数组整合为一个有序排列数组
   1. 双指针法
3. 三数求和
   1. 双爆指针

### 2. 总结

1. 通过map和指针来简化数组的循环

## 2. 字符串

### 1. 体型

1. 回文字符串的判断及衍生问题（衍生的问题其实就是要先对字符串做一定的处理，然后再去判断是否为字符串）
2. 正则的使用



### 2. 总结

1. 回文字符串
   1. 特征：对称性
2. 判断是否为回文字符串
   1. 通过对称性来判断---可以简化判断过程中的循环次数---循环其长度的一半
   2. **字符串都是可以转换为数组，然后就可以通过指针来简化了** 

## 3. 链表

### 1. 题型

1. 链表的处理：合并、删除等（删除操作画个记号，重点中的重点！）
   1. 延申问题：dummy结点
   2. hummy结点的作用：处理链表中的第一个结点
      1. 我们前面的链表的第一个结点没有前驱结点，所以有时候没办法进行处理
      2. dummy结点就是认为制造出来的第一个结点的前驱结点
2. 链表的反转及其衍生题目
3. 链表成环问题及其衍生题目

### 2. 总结

1. 链表处理类问题的核心---**处理链表结点之间的指针关系**  ！！！

   1. 链表的循环---while

      1. 循环中的指针移动---当前指针等于下一个指针
         1. cur=cur.next
      2. 注意：这个cur不能是原始值，否则的话就会直接将原始值改变---将原始值的指针长度随着循环一直在缩短
         1. 这也是为什么我们要重新复制一个，而且是直接复制，不会采用深拷贝的方式---因为在指针移动的过程中还需要去改变原始值。
         2. 本质就是cur每次移动后，其实就相当于是原始值的其实一个指针。又因为是复杂数据的等号复制，所以改变cur 的值会改变原始值。

   2. 代码

      ```javascript
      //1. 指针的合并
          // 真题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。
          // 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4
      
          //核心思想：链表处理，本质就是链表的指针的处理
          function fn(l1,l2) {
              //1. 创建链表的头部
              var head={
                  val:'',
                  next:null
              };
              //  这一步至关重要！！！！！！！
              //指针本身是一个对象，通过复制的方式，我们创建了一个可以移动的点，同时在移动的过程中还能影响到初始指针本身
              var cur=head;
              //2. 循环传入的两个链表---循环条件是两个链表都存在时
              while (l1&&l2) {
                  if (l1.val<=l2.val) {
                      //1. 给每次循环的首点添加后续指针结点
                      cur.next=l1;
                      //2. 每次添加结点后要将结点向后移动一位
                      cur=cur.next;
                      l1=l1.next;
                  }else{
                      cur.next=l2;
                      cur=cur.next;
                      l2=l2.next;
                  }
              }
              if (!l1&&l2) {
                  cur.next=l2;
              }
              if (l1&&!l2) {
                  cur.next=l1;
              }
              return head;
          }
      //2. 指针的删除
      // 真题描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
      
          // 示例 1:
          // 输入: 1 -> 1 -> 2
          // 输出: 1 -> 2
          // 示例 2:
          // 输入: 1 -> 1 -> 2 -> 3 -> 3
          // 输出: 1 -> 2 -> 3
          function fn(head) {
              var cur=head;
              while (cur.next!==null&&cur.val!==null) {
                  if (cur.next.val===cur.val) {
                      cur.next=cur.next.next;
                      //为啥没有下一步？---因为如果相等的话，就去掉中间的那个点，但是不能进行移动，要继续去判断，否则有连续三个相等的情况的话就会出现错误
                      // cur=cur.next
                  }else{
                      //如果没有相等的话就指针移动
                      cur=cur.next
                  }
              }
              return head;
          }
          var obj={
              val:1,
              next:{
                  val:1,
                  next:{
                      val:2,
                      next:null
                  }
              }
          }
          var newObj=fn(obj);
          console.log(newObj);
      ```

2. **dummy结点不管用不用都可以先设了，有的题目不设dummy结点思路打不开，但是哪怕dummy结点没用上也不会有什么问题！！！**  

3. **只要是链表要进行循环操作，那么必须要创建一个cur结点，用于定位链表此时循环到的位置！！！！**   

4. **指针其实就是对数据结构中的每个数据的获取，也就是“增删改查”中的查。而遍历本质上来说其实是其中最常规的指针（按照数据结构的顺序去获取）。那我们在算法中使用到的指针其实就是根据需要自行设定的查找顺序的。**

   1. **对于不同的数据类型，我们创建指针，移动指针的方法也不同。如数组和链表。**   

5. **链表的操作其实就是对链表结点间的指针的处理**    

## 4. 栈

### 1. 特性

1. 对称性---先进后出
   1.  一个数组的进栈顺序和出栈顺序正好相反
2. 操作
   1. 只能进行push操作和pop操作
3. 注意栈的对称性和回文字符串的对称性的差别
4.  **栈结构可以帮我们避免重复操作**。
   避免重复操作的秘诀就是**及时地将不必要的数据出栈**，避免它对我们后续的遍历产生干扰 

### 2. 体型

1.  题目中若涉及括号问题，则很有可能和栈相关。 
   1. 共同的特性就是对称性
      1. 和回文字符串的对称性不同，回文字符串的对称是字符串完全相同，而这个对称性是指两个一一对应的字符在字符串中的整体存在位置
2. 栈题目的进阶---温度问题
   1. 通过栈来避免重复操作---及时将不必要的数据出栈

## 5.队列

### 1. 特性：

1. 先进先出

### 2. 题型

1. 通过栈实现队列---两个栈实现队列
2. 双端队列- **双端队列就是允许在队列的两端进行插入和删除的队列**  

### 3. 栈和队列

1. 根据特性---先进后出对应括号体型，先进先出对应通过栈来实现队列。
2. 不管是栈还是队列都会使用其来创建一个递减数组，从而来实现对滑动窗口以及温度的体型。

## 6. 深度遍历

### 1. 深度优先搜索---DFS

	1.  **深度优先搜索的核心思想，是试图  穷举   所有的完整路径**。 
 	2.  **深度优先搜索的本质---栈结构**  

**思路：DFS---深度优先搜索---穷举---递归（类似与二叉树的先序递归）**   ---**一般来说，可以采用DFS的，都可以通过树结构来描述整个过程---所以我们在分析的时候一定要先分析清楚整个过程，然后观察可以通过什么数据结构来模仿，随后决定使用什么方式来解决**   

**数据结构：栈（先进后出，后进先出---当某个结点不通时则会清出栈结构）**  

```javascript
/*分析：这道题选择的方法仍然是深度优先搜索。
                DFS---树结构和递归，
                        树结构---坑位---不变的东西
                        递归---递归式和递归边界
                                递归式其实就是每个坑位的执行步骤
                                而递归边界则是坑位变化了---不变的东西要发生变化的时候
    */
//要进行递归操作的肯定是坑位，也就是说递归的本质就是坑位的移动
```

### 2. 广度优先搜索---BFS

1. 广度优先搜索和**队列**  的数据结构有紧密的联系！！！
2. 广度优先搜索---类似与分层的扫描
3. 不适用递归了，所以一想到穷举就联系到DFS

**思路：BFS---广度优先搜索---扫描---层次（类似于二叉树的层次递归） **  

**数据结构：队列（先进先出---广度优先搜索着重于眼前，当执行完某个结点后，如果当前结点不是目标结点，那么会将后续的结点入队列，而执行过的结点就会清出队列）**  