/*
    vue作为一个框架，我们在考虑特性的时候就要从其使用上及结构上的一些特点来考虑。

    一：基本特性
        1. 生命周期
            1. vue实例在创建、运行和销毁期间会触发一些事件，这些事件就叫生命周期函数
            2. 生命周期分为三个阶段：创建阶段、运行阶段和销毁阶段
            3. 
                1. 创建阶段：beforeCreated   created   beforeMounted   mounted
                2. 运行阶段：beforeUpdate  updated
                3. 销毁阶段： beforeDestroy  destroyed
            3. created：实例在内存中创建完毕，此时data和method已经创建完成，DOM没有渲染
            4. mounted：模板渲染到浏览器，即将进入运行阶段
            5. 一般我们都是通过created钩子函数进行一些数据的请求或者处理。但是也有在mounted中进行的。这是因为有一些操作必须使用到DOM元素。比如echarts插件的使用。
            6. keep-alive
                1. 用于：缓冲某个路由
                2. 应用场景：在某个页面中，我们切换展示内容。如果设置了某个类型内容的为keep-alive，那么当我们查看了一部分内容后，进行了切换，再此回来后，页面保持不变。
                3. 本质：增加了两个钩子函数：activated和deavtivated。当页面切走时，不会执行销毁函数，而是执行deactivated钩子函数。页面再次进入时也不会执行创建阶段的钩子函数。这样，页面就不会进行刷新。
                4. 特性：
                    1. 可以通过include和exclude属性设置要进行缓冲的页面
                    2. 必须使用keep-alive标签包住router-view标签。
        2. 组件通信
            1. props 和  $emit
                1.用于父子传值
                2. 特点：
                    1. 响应式的
                    2. 必须是父子的，而不是父辈和字辈关系
                    3. 可以父给子，也可以子给父
            2. provide  和  inject 
                1. 用于父子通信
                2. 特点：
                    1. 响应式
                    2. 可以是父辈和字辈的关系。只能由父辈传值
                    3. 子辈只有调用的权限，而不能给父辈传值
            3. $parent  $children
                1. 用于父子组件
                2. 可以获取到子组件、父组件的实例。通过实例我们可以获取到其上的数据和方法。
            4. v-model
                1. 通过v-model给子组件传值，会自动给props传入一个value的值。同时在子组件中我们也可以通过调用$emit('input')的方法去给父组件进行传值
            5. new bus
                1. 用于全局的通信
                2. 方法：
                    1. 创建一个vue实例
                    2. 这个实例要进行那些组件的通信，就把那些组件作为公共bus的子组件
                    3. 然后在所有的子组件中引入这个bus
                    4. 要进行传值的bus，使用bug.$emit('message',message)进行传值
                    5. 要接受数据的子组件中，使用bug.$on('message',(val)=>{操作})进行接受数据已经回调处理。
                3. 特点：
                    1. 可以全局使用
                    2. 很麻烦，现在我们大多出情况使用的都是vuex
            6. vuex
        3. vuex
            1. 要使用的话有两步重点---这也意味着vuex本质上有两个特点：
                1. 单例模式---vuex的构造函数只能返回第一次调用时的实例
                2. 在new Vue的时候，将vuex的实例注入到vue实例的跟组件中，这样vue的所有组件都可以通过this.$store来放问到vuex的实例
                3. 特点使用及分析
                    1. 使用vuex   vue.use(vuex)
                    2. 将vuex实例注入到vue跟组件中
                        在ming.js文件中。 new Vue({
                            store:new Vuex.Store(store)
                        })
                    3. 单例模式
                        在这里的作用：一个Vue实例只能对应一个Store
                        calss Vuex{
                            constructor(name){
                                this.name=name
                            }
                            static Store(){
                                if(!this.hasCreated){
                                    this.hasCreated=new Vuex();
                                }
                                return this.hasCreated
                            }
                        }
            2. 其他的就是vuex使用时候的一些方法
                1. state用于存储状态（数据）
                2. mutation：唯一用于修改状态的同步方法集合
                3. action：通过操作mutation来修改状态，且可以进行异步操作
                4. 还有就是一些辅助方法了。
        
        4. 路由
            1. router-view 进行占位，子组件中的vue页面，根据路由选择展示在这个位置
            2. router-link标签，类似于a标签。可以根据属性设定要跳转的页面。和a标签的区别就是a标签是利用网址进行跳转，而这个标签是根据路由。且这个本质上并没有页面跳转，而是路由的切换，即vue组件的切换。
            3. 编程式导航
                1. $router.go() 可以是正数，也可以是负数，也可以为0.0标识当前页面刷新
                2. $router.back()  返回上一个页面
                3. $router.push()   跳转至某个页面，传入路由
            4. 路由守卫
                1. 每个路由守卫，传入一个函数，函数有三个参数（to,from ,next）。
                2. 前置路由守卫，我们可以进行权限验证
            5. 拦截器--=-不对，这是axios的
                1. 请求拦截器---可以进行遮罩层的设置
                2. 响应拦截器---可以设置响应状态码的判断，然后进行提醒。
            6. 哈希模式和history模式
                1. 哈希模式和history模式的区别：
                    1. 哈希模式在地址中有#号拼接在请求地址后面的路由地址。即我们的路由加入是/login，那么在地址上其实是#/login。而history模式不会
                    2. hash模式传递参数是基于url进行的，就是拼接在url后面。不能传递复杂及体积较大的参数。而history模式可以将参数放到某个特定的对象中传递。
                    3. history模式可以使用浏览器的go方法和back方法等等。而哈希模式不能。
                2. 而对于vue的区别，就只是二者的地址样式。因为history模式下可以使用浏览器的go back 等方法。而vue路由本身的这些方法就是基于history模式的。同时，从路由传参的方法上我们也可以知道vue的路由传参方式是两个方式的传参方式都支持。
                3. 如果vue想要使用history模式，那么在服务器端要进行很多修改。vue默认的路由模式是hash模式。
        5. 插槽
            1. 作用：在父组件中，给子组件添加标签内容
            2. 类别：
                1. 匿名插槽 子组件放入一个slot标签，没有其他属性。父组件中，给子组件添加的标签全部填充到这个位置。
                2. 名命插槽  slot标签设置name属性。父组件中，给子组件添加标签时，每个标签都可以通过slot属性找到对应的命名插槽。
                    1. 命名插槽可以多个，也可以和匿名插槽混合使用。
                3. 作用域插槽  
                    1. 使用方法
                        1. 子组件  首先要设定名字，然后通过属性传递数据
                            <slot name='s1' :give="data"></slot>
                        2. 父组件 通过slot-scope接受参数（这个参数是所有数据的一个集合）
                            <div>
                                <son>
                                    <div slot="s1" slot-scope="stDate">{{stDate.message}}</div>
                                </son>
                            </div>
                    2. 特点：
                        1. 在父组件中，可以使用在插槽位置使用子组件传过来的值
                        2. 是响应式的
                    3. 本质：vue内部应该是有作用域插槽的编译的。当每次数据更新时，会进行响应式操作。在模板编译时，发现有作用域插槽，那么就会同步进行数据的更新的。那么这个编译的标识应该就是slot-scope属性。
                    4. 使用：比如element组件库的表格组件。我们传入表格的数据，然后在每一列可以通过slot-scope来获取到这个数据。这个其实就是我们把数据传入到子组件去，然后子组件通过作用域插槽传回来的。
                        同时，我们还可以在自定义标签时使用这个slot-scope属性。可能我们并没有使用到数据，但是我们需要这个标签是根据父组件的某个数据进行响应式的，那么久必须设置这个属性。
        6. mixins
            1. 作用：mixins是一个js文件，可以按照vue 模板设定JS部分，比如data数据，生命周期函数，methods方法等。然后在使用的组件中引入这个文件，设定为vue组件的mixins。那么这个组件就会将JS部分和mixins文件进行合并。
            2. 特点：
                1. 如果组件和mixins有冲突部分，比如数据名相同，方法相同等。会有限使用组件本身的。
                2. 对于钩子函数那么就会合并
            3. 注意
                1. 因为mixins可以多个组件使用。所以，当修改mixins的一部分内容，所有的引用组件都会有影响。
                2. 相当于创建了一个JS模板。每个引用这个模板的组件，都单独进行合并，然后生成了一个新的组件。
            4. 区别
                1. 和vuex的区别
                    1. vuex的数据是共同的。当一个引用位置修改数据，全局都会改变
                    2. mixins则是每个引用的组件是相互独立的。在一个组件中引入后，那个变量就独属于当前组件了。
                2. 和组件的区别
                    1. 在父组件中引入组件。二者的关系是相对独立的
                    2. 而mixins则是相互合并了
            5. 使用
                1. 比如websocket的使用。我们在创建websocket，建立连接，关闭连接，传递数据等基本上是一样的。所以有时候就会使用mixins来进行混用的。
        7. 监听属性和计算属性
            1. 监听属性  watch
                1. 作用：监听某个变量，当变量发生变化时，触发回调函数。是响应式的。
                2. 注意：
                    1. 对于复杂数据直接监听是监听不到的。---由于复杂数据的引用问题。此时可以通过深度监听实现。
                    2. 尽可能的不要使用深度监听。可以单独监听某个对象上的某个属性。
                3. 本质：
                    1. watch本质上就是Object.defineproperty的使用
            2. 计算属性  computed
                1. 作用  通过回调函数创建变量。每次调用这个计算属性时，都会检查其内部引用的变量是否发生了变化。如果发生变化，就会重新计算。如果没有变化，就会从内存中直接取值，不进行计算。
                2. 特点：
                    1. 可以缓冲
                    2. 依赖其他数据
                2. 区别
                    1. 和方法相比
                        可以进行缓冲的
                    2. 和普通属性相比
                        必须是一个函数
            3. watch和computed的区别
                1. computed能做的，watch全都能做
                2. 能computed的，尽量不要watch。
                    1. 因为computed是可以缓冲的，可以减少不必要的计算
                    2. 如果同时需要监听多个数据，且作用于同一个结果。那么使用computed就可以大大减少代码量。同时也可以大大减少计算量。
        8. 自定义指令  directives   在页面中设置，全局的差不多
            1. 使用方法
                1. directives:{   //和data同级
                    loadmore：{
                        inserted(el,binding){
                            执行业务代码，满足一定条件后
                            binding.value();//执行指令传入的回调函数
                        }
                    }
                }
                生命完毕，在标签上使用v-loadmore="回调函数"
                2. 这里使用的是inserted，还有bind、unbind等。相当于是指令的钩子函数。
                    区别：
                        1. inserted ：当被绑定元素插入到父节点中调用（宝成父节点的存在）
                        2. bind：只调用一次，在指令绑定到元素上时调用
                        3. unbind：只调用一次，在指令和元素解绑时调用。
                3. 使用场景
                    自定义指令对底层DOM进行操作
                    1. 当我们需要给某个标签绑定一个事件，但是这个标签我们并不知道什么时候存在。比如这个标签在一个弹窗框中，那我们没办法去获取到什么时候存在。如果使用watch的话，此时可能标签并没有渲染完毕。那么我们就可以通过自定义指令来实现。当这个标签存在，且保证其父标签存在时，我们通过自定义指令的钩子函数让其执行。

        9. nextTick
            1. 传参：传入一个回调函数
            2. 作用：当DOM渲染完毕后再执行nextTick中的回调
            3. 本质：
                1. 页面渲染是一个异步操作
                2. 这里就相当于借助宏任务和微任务实现异步代码的同步执行效果。相当于创建了一个微任务，这个微任务是依赖于DOM渲染这个异步宏任务的。
            4. 使用场景
                1. 我们发起请求获取数据，这些数据导致页面变化。我们需要DOM改变以后进行某些操作。那么就要使用this.$nextTick
        10. 虚拟DOM
            1. vue渲染流程
                数据改变引发模板编译，编译生成虚拟DOM（vietual DOM），和原来的虚拟DOM进行比对，找到最佳的渲染方法，最后进行页面渲染
            2. 特点
                1. 通过虚拟DOM来描述真实DOM，将DOM的比对放到JS中进行
                2. 通过diff算法找到最佳的渲染方式，避免不必要的DOM渲染
            3. 作用
                1. 可以跨平台，因为虚拟DOM是基于JS环境的
                2. 提高运算速度。JS代码执行的速度是远高于DOM运算的。把DOM对比放到JS中进行，可以极大的提升运算速度
                3. 提高渲染性能。通过diff算法找到最佳的渲染方式，避免一些不必要的DOM渲染，极大的提高渲染性能。
        11. vue的组件封装
            vue的组件封装我们一般注意三个部分
                1. 数据交互
                    这里主要设计到父子组件的一个信息交互。
                2. 模板交互
                    这里我们主要使用插槽。然后插槽一般也是作用域插槽。因为作用域插槽不仅可以实现模板和数据的传递，还可以实现数据的动态响应。
                3. 事件
        12. vue的key属性的作用
            1. 我们使用v-for进行遍历。当遍历的这个数组发生长度改变时。如果没有key属性，那么就会把所有遍历的旧元素清除，然后再次生成新元素。如果有key值，比如是下标。那么当在数组前面添加一个元素后，vue是根据其下标去对应的位置增加一个元素。而不是全部更新了。
            2. 使用key属性强制替换元素。当key值发生改变时，vue认为一个新的元素诞生了，从而会新插入一个元素代替之前旧的元素。如果key值使用在组件上，那么就会触发组件的钩子函数。
        13. vue的v-model原理
            v-model就是vue的双向绑定，实现的功能就是从数据到视图，以及从视图到数据的响应。
            1. 从数据到视图
                从数据到视图，使用的是Object.defineproperty的get和set方法。在set中，当data数据发生改变时，就会通知对应的位置进行模板中数据的刷新。
            2. 从视图到数据
                从视图到数据，借用的是input事件。在模板编译的过程中，遇到v-model属性的，就会给他添加对应的input事件。当检测到用于进行内容输入时，就会通知对应的数据发生修改。
                    
*/