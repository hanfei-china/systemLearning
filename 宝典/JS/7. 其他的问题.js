/*
    1. 防抖、节流
        1. 防抖---只用最后一次。
            1. 分析：使用定时器，当一定时间段内，再次触发的话就会清除掉这个定时器。只有最后一次进入后，过了一定时间段后，这个定时器才能触发。进而到达防抖的目的。
            2. 使用场合：一般用在输入框的地方。
        2. 节流---一段时间内只通过一次，就是一段时间内只有第一次有效。
            1. 分析：使用定时器，以及一个标识。当第一次进去后，会修改这个标识，然后触发定时器。在这个时间段内，其他触发进入函数中的，都会因为标识的问题直接返回，不会再次触发定时器。当定时器执行完毕后，会再次将标识复原，进而允许之后的触发动作有效。
            2. 使用场合：一般使用在触发次数特别多，然而我们可能只需要等时间段的去处理其中的一部分即可。比如鼠标移动事件，让图片跟随鼠标移动。此时就可以进行节流。

    2. 首页懒加载
        1. 首先，所有的img标签的CSS样式都按照正常来设置，要有占位。同时，也要设置其src属性为空，再自定义一个属性用于存储正确的图片地址。
        2. 然后，获取所有的img标签---数组imgs。同时，获取当前浏览器的可视区域的高度viewHeight。
        3. 监听window的鼠标移动事件。
            1. 遍历图片集合
            2. 获取每个标签距离可视区域的顶部的距离。
            3. 如果这个距离小于可视区域的高度，那么说明这个标签进入到可视区域中了。
            4. 那就获取自定义属性上的地址信息，然后给到src属性上。
        4. 优化
            1. 每次鼠标移动，都会重新去遍历、计算、赋值，没必要
                创建一个全局变量，存储移动的位置。
                    1. var num=0;
                    2. 在遍历时，从num开始。每次有处于可视区域中的都要将num加一
                    原理：移动的时候是从上到下的，而我们获取的标签也是从上到下有顺序的。
            2. 鼠标一直移动，那么一直执行
                可以采用当都或者节流。

    3. 浏览器
        1. 浏览器组成及网页加载流程
            1. 浏览器组成是渲染引擎和JS引擎。
            2.渲染引擎工作流程
                1. 将HTML代码转换为DOM树，将CSS转换为CSSOM树
                2. 将DOM树和CSSOM树结合为渲染树（render树）
                3. 布局：计算render树的布局（布局流）
                4. 绘制：将render树绘制到屏幕上
            3. 浏览器的工作流程：
                1. 页面加载并渲染。---一边加载一边渲染
                2. 当遇到script标签时，将主导权交给JS引擎。
                3. JS引擎运行。当遇到外部资源加载时，先加载，在执行JS代码。
                4. 当JS代码执行完毕后，再把主导权交给渲染引擎。
            4. 注意事项
                1. 从上面我们知道，JS引擎的优先级更高。因此我们一般把JS代码放到body标签后面或者最下面
                    那如果不这样做，可能会导致什么结果？
                    造成阻塞效应
                        1. 当外部资源较大时，一直处于下载状态，后面的代码没办法执行。页面也一直不能渲染
                        2. 当HTML代码没有渲染完毕时，此时执行JS代码，很有可能报错。
                2. 渲染过程中的布局和渲染都是有阻塞效应的。所以我们在JS代码中要尽可能的避免重绘以及重流。
                    1. 重流一定会导致重绘，但是重绘不一定会造成重流。
                    2. 当我们在JS代码中进行布局的变换时，必然导致重流。所以我们一般都是尽可能的避免布局改变，尽可能的改变CSS样式来达到效果。

                3. 关于重流和重绘相关的优化
                    1. 尽可能的一次性的去修改DOM，不要分开的频繁的去操作修改DOM
                    2. 如果修改样式的话，也尽可能的通过class，一次性的修改。这也是为什么我们尽可能的去使用通用样式。
                    3. 使用虚拟DOM---vue就是这样来做的
        2. localStorage和sessionStorage
            localStaorage是永久存储，只有当我们执行删除操作时才会清除。
            而sessoinstaorage是临时存储，当前会话结束时就会清除。
        3. 同源策略及跨域
            1. 同源策略的要求：
                1. 协议相同
                2. 域名相同
                3. 端口相同
            2. 同源策略：
                如果非同源，那么服务器会照常相应，但是浏览器会进行拦截。
            3. 跨域方法：
                1. JSONP
                    1. 优点：兼容好，后端改动小
                    2. 缺点：只能是GET请求
                2. CORS
                    1. 优点：什么请求都支持，可以请求的文件可以较大
                    2. 缺点：兼容性不太好，且后端修改较大
                    3.原理：通过请求头的信息，判断域名是否在自己的白名单中。如果不在，那么相应头中会少一个字段，从而告知浏览器。

    4. 垃圾回收及内存泄漏
        我们通过一个循环引用bug来解释两种垃圾清除方式
        function fn(){
            var a={
                name:b
            };
            var b={
                age:a
            }
        }
        1. 引用清除
            1. 原理：计算每个变量的引用数，当引用数为0时，就可以被清除了。
            2. 缺点：当发生循环引用时，哪怕这两个变量在其他地方没有被引用了，也不会清除。
                如上例：当函数执行完毕后，函数销毁。但是由于那两个变量相互引用，所以即便函数销毁了，也不会清除这两个变量的内存。
        2. 标记清除法
            1. 从根全局变量进行遍历。如浏览器环境中的根全局变量就是window。每一个能被根全局变量放问到的变量，都会进行标记。那么遍历结束后，没有被标记的变量，就可以被清除了。
            2. 那么针对上面的例子，如果采用的是标记清除法，函数执行完毕并销毁后，全局变量是访问不到其内部的变量的，所以，即便是循环依赖了，也会被清除。
            3. 缺点：如果设置了很多全局变量，那么即便不被依赖了，也不会被清除。
        3. 造成内存泄漏的原因：
            1. 声明了很多全局变量
            2. 形成闭包
            3. 没有销毁的回调或者定时器
        4. 如何避免造成内存泄漏
            1. 尽可能少的去声明全局变量
            2. 减少闭包的使用
            3. 避免形成相互依赖的死循环

    5.HTTP
        1. 三次握手   以A为客户端，以B为服务器。以SYN  ACK为标志
            1. A→B   可以吗？
            2. B→A  可以，确定吗
            3. A→B  确定，连接吧
        2. 四次挥手
            1.A→B  可以断开吗？
            2.B→A  可以，我先检查一下
            3.B→A  可以断开啦
            4.A→B  好的，再见
        3. HTTP连接的特点
            1. 单向连接。只能由客户端发起连接或者断开的请求
            2. 长连接。只要任意一端没有提出断开连接请求，那么就会一直保持连接状态。避免频繁的进行连接断开。
            3. websocket  双向连接。
        4. HTTP的状态码
            1. 2xx   请求成功
            2. 3xx   重定向
            3. 4xx   客户端请求出错，比如请求参数缺失，格式错误等等
            4. 5xx   服务器处理请求出错
        5. http请求的缺点
            1. 通信使用明文，可能被窃听
            2. 不验证通信双方身份，可能遭遇伪装
            3. 不能确定报文的完整性，可能被修改
        5. https请求的特点
            1. 通信使用了密钥加密，建立安全的通信通道
            2. 提供证书来进行身份验证
            3. 提供摘要，用来确定报文的完整性
            4. 比http请求要慢2~100倍
        6. 单点登录---http的应用
            1. 有三个网站要使用同一套密码进行登录。
            2. 用户放问这三个服务器时，在登录验证时都会进行重定向，重定向到第四个服务器。
            3. 第四个服务器专门用于进行登录验证。
            4. 如果验证通过，那么就会重新重定向至对应服务器的首页。这样就实现了单点登录效果。

    6. webpack
        webpack有四个核心
            1. 入口文件   entry  设置入口文件---一般是我们开发的主文件
            2. 出口   output  用于设置打包文件的路径以及文件名等。
            3. plugin  插件功能   可以安装一些便于开发的插件，webpack可以帮我们自动引入这些js文件。 
                在开发中，如果没有这个插件功能。我们每次使用都要手动去引入这个JS文件，更改代码后还要重新编译。很麻烦，而plugin就是帮我们完成这部分工作
            4. loader  用于对文件进行编译
                1. babel-loader   用于对ES6进行降级编译，因为有一些浏览器还不支持ES6语法
                2. CSS-loader  style-loader   用于处理CSS文件
                    1. 在安装时，必须要先安装style-loader
                    2. css-loader  用于提取JS中引入的CSS文件
                    3. style-loader   用于在HTML中创建一个style标签，盛放CSS-loader编译出来的CSS样式
                3. less-loader   编译less代码
        webpack有两种模式：开发模式和生产模式
            1. 开发模式需要调试，需要自动打开浏览器。而生产模式不需要
            2. 生产模式需要设置打包文件目录，需要启用压缩，而开发模式不需要。
            3. 以上两种模式及需求是通过配置文件的配置来实现的。
    7. ajax流程
        1. 创建Ajax对象   xhr=new HttpRequest()
        2. 规定请求地址   xhr.open(methods,url,async)
        3. 发起请求       xhr.send()
        4. 等待服务器回复  xhr.onload
    8. 浏览器兼容问题
        样式兼容
            样式兼容一般我们使用通配符进行全局的样式设定。比如 *{margin:0;padding:0}
        交互兼容
            1. 事件对象兼容问题
                谷歌浏览器的事件对象通过事件传入，而IE的则是window。event
            2. 注册事件的兼容问题
                谷歌浏览器的事件注册是addEventListener，IE的则是attachEvent
    9. 苹果和安卓的兼容问题
        1. iPhoneX 手机底部安全区域问题
            在app.js文件的onLaunch函数中，我们可以去设置型号，然后把这个数据放到全局变量app.gloableData中。然后在使用的页面中，可以过去到这个数据，然后设置底部安全距离。
        2. 微信小程序中IOS的new Date()不兼容问题
            在实现倒计时，根据后台返回的时间格式转换时，后台返回了时间格式为”2018-11-12 11:12:11”，然后利用new Date() 转换时，ios中无法展示，安卓中显示正常
            方法：把时间格式中的-转换为/    time.replace(/-/g,'/')
    10. fetch 
        1. 目前大多前端使用的请求方式都是axios，但是现在axios的体积已经越来越大了，所以就出现了fetch
        2. fetch对于IE8的兼容性不是很好，需要安装一些插件
        3. fetch返回的也是一个promise对象

*/

//防抖
var fangdou = (function fn1(time) {
    var timer = null;
    return function () {
        clearTimeout(timer);
        timer=setTimeout(() => {
            console.log(111);
        }, time);
    }
})(1000);

//节流
var jieliu = (function (time) {
    var flag = true;
    return function () {
        if (!flag) {
            return
        }
        flag = false;
        setTimeout(() => {
            flag = true;
            console.log(111);
        }, time);
    }
})(800);

//懒加载
function lazyLoad() {
    var imgs = [];//存储所有标签---生产中需要去获取的
    var viewHeight = 600;//可视区域的高度
    var num = 0;//记录加载的位置
    window.addEventListener('mousemove',function () {
        for (let i = num; i < imgs.length; i++) {
            var height = imgs[i].getBoundingClientRect().top;//记录每个元素距离可视区域的顶部的距离
            if (height<viewHeight) {
                imgs[i].src = imgs[i].getAttribute('src-img');//获取地址信息，并赋值
                num++;
            }
        }
    })
}

//JSONP实现跨域
function jsonp(src) {
    function callback() {
        console.log('执行回调');
        document.body.removeChild(script);
    }
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    script.src = src+'?callback='+callback;//千万要注意加回调函数的
    document.body.appendChild(script);

}